#!/bin/bash

MERGE_COMMAND="git merge"
hash compgen 2>/dev/null && compgen -A command "git-ci" >/dev/null && MERGE_COMMAND="git ci --merge"

# ============================================ R E V I E W =========================================================

SOURCE=$(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/' -e 's/^[[:space:]]*//' -e 's/(HEAD detached at //' -e 's/)//')
TARGET=master

function get-back {
    git checkout "$TARGET" 2>1 >/dev/null
}

if [[ $1 = "-p" || $1 = "--pull" ]]
then
    shift
    announce "Fetching the data..."
    TARGET="$SOURCE"
    SOURCE=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" | sed -e 's/(HEAD detached at //' -e 's/)//')
    
    git fetch --prune
    
    git checkout "$SOURCE" 2>1 >/dev/null
    
    trap get-back INT
    
    git review "$TARGET" $*
    get-back
    exit 0
fi

if [[ $1 != "" ]]
then
    TARGET="$1"
fi

announce -nn "Source:"
echo -e "$SOURCE"

announce -nn "Target:"
read -r -i "$TARGET" -e TARGET

COMMITS=$(git log --reverse --pretty=format:'%h' $TARGET..$SOURCE)
COMMITNUMBER="$(echo $COMMITS | wc -w)"

if [[ $COMMITNUMBER -eq 0 ]]
then
    announce "The two branches are identical, there is nothing to do."
    exit 0
fi

announce "There are ${COMMITNUMBER} commits. How do you want to review them?"
echo " 0. One-by-one"
echo " 1. As one"
announce -nn "Your choice:"
read -r REVIEW_MODE

function as-one {
    git diff "$TARGET".."$SOURCE"

    announce -nn "Accept? (y/N)"
    read -r ACCEPT

    case $ACCEPT in
    y|yes)
        echo "Merge accepted.";;
    *)
        echo "Aborting."
        exit 0;;
    esac
}

function one-by-one {
    for COMMIT in $COMMITS
    do
        git show --show-signature $COMMIT

        announce -nn "Accept? (y/N)"
        read -r ACCEPT

        case $ACCEPT in
        y|yes)
            echo "Commit $COMMIT accepted.";;
        *)
            echo "Aborting."
            exit 0;;
        esac
    done
    announce "You accepted all commits."
}

case $REVIEW_MODE in
0)
    one-by-one;;
1)
    as-one;;
*)
    echo "Wrong input."
    exit 1;;
esac

# ======================================= M E R G E ================================================================

announce "Choose your merge method:"
echo " 0. Merge     Recommended for beginners"
echo " 1. Rebase    Cleaner, but harder"
echo " 2. Squash    Not recommended"
announce -nn "Your choice:"
read -r MERGE_METHOD

function merge {
    git checkout "$TARGET" 2>1 >/dev/null
    OPTIONS="--stat --no-squash"

    if git merge-base --is-ancestor "$TARGET" "$SOURCE"
    then
        announce -nn "This branch can be fast-forwarded. Do you want to? (y/N)"
        read -r ALLOW_FF

        case $ALLOW_FF in
        y|yes)
            echo "Allowing fast-forward..."
            OPTIONS+=" --ff-only"
            MERGE_COMMAND="git merge";;
        *)
            echo "Forbidding fast-forward..."
            OPTIONS+=" --no-ff";;
        esac
    fi

    announce "$MERGE_COMMAND $OPTIONS $SOURCE"
    # shellcheck disable=SC2086
    $MERGE_COMMAND $OPTIONS "$SOURCE"
}

function rebase {
    announce "git rebase --interactive $TARGET"
    git rebase -i "$TARGET"
    announce "git checkout $TARGET"
    git checkout "$TARGET"
    announce "git merge --ff-only $TARGET"
    git merge --ff-only "$TARGET"
}

function squash {
    announce "$MERGE_COMMAND --stat --squash $TARGET"
    $MERGE_COMMAND --stat --squash "$TARGET"
}

case $MERGE_METHOD in
0|m|merge)
    merge;;
1|r|rebase)
    rebase;;
2|s|squash)
    squash;;
*)
    echo "Wrong input.";;
esac

git checkout "$TARGET"
